#summary Won't fix issues that make Python less pythonic.

http://www.catb.org/jargon/html/W/wart.html

== Why Python is with warts? ==

Over years of dealing with warts, I can name a few reasons why they appear in Python. Python is a community project, so the primary reason is a communication failure. From thousands of People using Python few are able to track what happens with Python development. Even less have time and skills needed to provide and defend right arguments.

Zen of Python is a very good thing to set the rules for language evolution, but insufficient when we go deeper into specifics of user experience problems. I wish it could be extended to include this:

  1. User data should be platform independent, so when dealing with it, cross-platform behavior should be put first. If data needs to be handled in operating system specific way, this should be explicit (see open() on Python 3 wart below).

  2. When making core function API make sure that it does one thing. A lessons to study - subprocess.Popen and Python 3.3 open() encoding selection logic.

Contents:

<wiki:toc />

= Input/Output Issues =
== open() on python 3 uses default system encoding ==
If you use Python 3. If your text file in UTF-8. And if you're reading it without explicit encoding, you're screwed `[`[https://bitbucket.org/techtonik/hexdump/pull-request/1/since-the-input-file-is-a-specific/diff 1]`]`. That's because some user will probably has system with Greek locale, and it will be the encoding that Python will try to open the file in.

*recommendation*: Text files should be opened in universal encoding. UTF-8 is the backward compatible and most popular way.

== stdout buffering ==
Python is a victim of premature optimization.
{{{
import sys
import time

print("get", end="")
time.sleep(3)
print("me")
time.sleep(3)
sys.stdout.write("onscreen")
time.sleep(3)
}}}
In this code phrases "get" and "onscreen" appear only after the sleep operation (Linux, Python 3.2).  To turn this off you need [http://stackoverflow.com/questions/107705/python-output-buffering some monkey-patching hacks].

New Python users are not aware of various buffering magic, so this issue comes to be very confusing for them. The question that print without newline doesn't work is [http://stackoverflow.com/questions/tagged/python?page=1&sort=votes&pagesize=50 45th from top 100] on StackOverflow. Note that if output is redirected to a file or a socket, new lines won't cause the buffer to flush. You need to flush output stream explicitly if you want the output from Python script to appear ASAP.

== stdout is in text mode by default ==

Python produces broken binary data if you just write them (or print) to stdout.

Python 2, Windows:
{{{
> python -c "import sys; sys.stdout.write('_\n_')" > 2
> python -c "print repr(open('2', 'rb').read())"
'_\r\n_'
}}}

To fix it, you need to use hacks:
Python 2, Windows:
{{{
import sys

if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

sys.stdout.write('_\n_')
}}}

{{{
TODO - Python 2, Linux
TODO - Python 2, OS X
TODO - Python 3, Windows
TODO - Python 3, Linux
TODO - Python 3, OS X
}}}

== Python 2 misses non-ASCII filenames ==

On Windows, if you use non-unicode string as `os.walk` or `os.listdir` argument, you will end up with filename composed of question marks for non-ASCII local symbols. Filenames that you won't be able to open.


= Everything Else =
== mutable defaults trap ==
{{{
def foo(bar=[]):
  bar.append(0)
  print(bar)

foo()
foo()
}}}

This gives:
{{{
[0]
[0, 0]
}}}
Some say that [http://pythonconquerstheuniverse.wordpress.com/2012/02/15/mutable-default-arguments/ this is a feature], but if to memorize a feature you need to be hit by it, and then learn language internals, that's a wart. The solution is to provide an explicit mechanism to define function specific variables that are preserved across function invocations. This will also help to detect such state preserving bugs when porting Python programs to be multithreaded.

== Logging ==

Standard Python logging suxx. Prooflinks:
 * [https://github.com/Supervisor/supervisor/blob/master/supervisor/loggers.py Supervisor]
 * [http://twistedmatrix.com/trac/wiki/TwistedLogging Twisted]
 * [http://sayspy.blogspot.com/2009/07/results-of-informal-poll-about-standard.html 3rd place in modules that need redesign]
 * [http://packages.python.org/Logbook/ Logbook - alternative with features that `logging` misses] 

{{{
Q: Why?
A: You will inevitably face with problems below and will have to read a
lengthy doc with proper explanations
Q: Why it can not be fixed?
A: Backwards compatibility
Q: Why not logging2?
A: Some Python developers do not feel that DMMT is sufficient reason
}}}

=== Logging hidden magic (2.x tested, 3.x unknown) ===

To make `logging` module more easy to use, e.g.
{{{
import logging

logging.error('SNAFU')
}}}
it makes an automatic configuration when any top level functions like logging.error() are called. More specifically, it implicitly calls `basicConfig()` which is a one-shot function that can be called only once.

As a result, if imported modules are using logging in simplified mode, you have to keep in mind different things about `basicConfig()` that are better to live without.

http://bugs.python.org/issue1164953

This behaviour is confusing for people, it's not intuitive. Consider the following two separate Python sessions:
{{{
>>> import logging as l
>>> l.error("x")
ERROR:root:x
>>> l.getLogger('x').error('x')
ERROR:x:x
}}}

{{{
>>> import logging as l
>>> l.getLogger('x').error('x')
No handlers could be found for logger "x"
}}}

http://bugs.python.org/issue1354052 <br/>
http://bugs.python.org/issue16539

It is also doubtful how to provide default logging configuration for a library? For example, when library wants to disable all output by default. If such library is imported after the main logging configuration that enables library output - then such import will break the config.


*recommendation* (ideal case) - Start with study of several use case scenarios:
 # basic 'logging' usage - 'import logging; logging.log()'
 # advanced usage - all imported modules are using 'import logging; logging.log()'
 # more advanced example - mixed usage of named and unnamed loggers in imported modules and root app
 # default behaviour - with two and three level hierarchy of modules


=== Logging best practices - specify `__name__` manually ===

Best practices recommend using module `__name__` variable as logger's name. `__name__`  that contains the name under which a module is imported.
{{{
import logging 
logger = logging.getLogger(__name__)
}}}

If the module is executed from command line, `__name__` will equal to `__main__`, if it is imported like `import trac.db.api` then the `__name__` will be equal to `trac.db.api`. Quite convenient.

Now about warts.
 # The first time you call warning(), error() or critical() you'll get 'No handlers could be found for logger "__main__" (Python 2.x, http://bugs.python.org/issue16539)

*recommendation* - For Python 2.x [http://hg.python.org/cpython/file/771f28686022/Lib/logging/__init__.py#l1669 copy NullHandler] from Python 2.7 to your library and add it as:
{{{
logger.addHandler(NullHandler())
}}}

Warts continued.
 # You need to insert the line `logger = logging.getLogger(__name__)` into every file, even though logging could detect this name automatically and invoke appropriate logger by default using inspect (example code at https://gist.github.com/1291125).
 # [http://docs.python.org/library/logging.html#logrecord-attributes Log record] contains `%(module)s` field that you can use to format message, but this is not the module `__name__` above - it is merely `name portion of %(filename)s`. You need to keep in mind that you need `%(name)s` - name of the logger - here.

*recommendation* - The above can be fixed with Python code, but a lot of logging calls incur performance overhead by logger choosing and filtering. However, if `__name__` convention is adopted by default, the Python internals can be reworked so that filtering is done on a interpreter level even before the code enters log() function.

== Subprocess ==

=== Subprocess - implicit argument conversion ===

[http://docs.python.org/library/subprocess.html Subprocess] module did a great job to reduce the number of various ways and pitfalls of executing external programs from Python, but it is not enough.

External programs can be executed directly, or from shell. Why the latter is required is not immediately obvious (IMO it should be explained in Python manual, but I am busy with [http://code.google.com/p/pydotorg/issues/detail?id=6 pydotorg:issue:6] to fix it the old way), but I guess it is to inherit environment variable to find your command is in %PATH%.

The way the program is executed is controlled by `shell` argument to the main subprocess function - `Popen`. However, this changes the meaning of the first argument (defining the command to be executed and its params)  quite significantly. That means it is possible to lose your arguments or pass them to the wrong command or just fail on one platform, but work on the other.

=== Subprocess - awkward API ===

If you ever looked at subprocess examples - you may have noticed how lengthy the commands are. Coupled with the above wart, this makes it almost absolutely impossible to use Python as a cross-platform replacement of shell language.

*What can be done?*
Provide helpers with consistent meaning of arguments aimed to solve particular user level tasks:
  # Execute command getting its output for further processing, e.g. `out = callout('svn log %s' % fname)
The argument above can be list only for the sake of quoting it properly (if needed).

=== Subprocess - things you can not do ===

  * .communicate() is recommended way to avoid deadlocks, but you can not split output into two streams to make it appear on screen during processing and stored in the output variable

== Measuring run time ==

_There should be one-- and preferably only one --obvious way to do it._
{{{
>>> from datetime import datetime
>>> s = datetime.now()
>>> str(datetime.now() - s)
'0:00:11.475000'
}}}

{{{
>>> from time import time
>>> s = time()
>>> str(time() - s)
'11.8889999389'
}}}

*What can be done?*
{{{
>>> import timer
>>> timer.get(precision=2)
'0:00:11.47'
>>> timer.start('newtimername')
>>> timer.get('newtimername')
'0:00:11.475000'
}}}

== scopes of Python - global and local variables ==
=== inaccessible intermediate scope in Python 2===
{{{
ora = 'cool'
def er():
    print ora,
er()
print ora
}}}
This prints `cool cool`.

{{{
ora = 'cool'
def er():
    ora = 'cept'
    print ora,
er()
print ora
}}}
This prints `cept cool`. Hopefully that's clear - inside `function scope` global variable is overridden by local variable.

{{{
ora = 'cool'
def er():
    global ora
    ora = 'cept'
    print ora,
er()
print ora
}}}
This prints `cept cept`. Hopefully that's also clear.

Now with new nested function.
{{{
ora = 'cool'
def er():
    ora = 'cepti'
    def ee():
        print ora, # prints first
    ee()
    print ora,     # second
er()
print ora          # last
}}}
`cepti cepti cool`

{{{
ora = 'cool'
def er():
    ora = 'cepti'
    def ee():
        ora = 'de'
        print ora, # prints first
    ee()
    print ora,     # second
er()
print ora          # last
}}}
`de cepti cool` - all fine.

{{{
ora = 'cool'
def er():
    ora = 'cepti'
    def ee():
        global ora
        ora = 'de'
        print ora, # prints first
    ee()
    print ora,     # second
er()
print ora          # last
}}}
`de cepti de`.

The wart of Python 2 is that there is no way you can modify the `cepti` part in the middle scope (without hacks). In Python 3 there is a `nonlocal` keyword for that.

But that's not important, because it is rarely used. It is important to completely understand the scoping rules to get the problem with `execfile()` right.

=== cryptic execfile() behavior in Python 2 ==

`execfile()` is useful for custom scripting in Python. You set imports and environment and execute script there. This is how SCons and similar tools work. In comparison to `import` `execfile()` doesn't create new module.

demo.py
{{{
ora = 'cool'
def er():
    print ora
er()
}}}

demorun.py
{{{
execfile('demo.py')
}}}
cool

Changing demorun.py
{{{
def run():
  execfile('demo.py')
run()
}}}
{{{
Traceback (most recent call last):
  File "demorun.py", line 3, in <module>
    run()
  File "demorun.py", line 2, in run
    execfile('demo.py')
  File "demo.py", line 4, in <module>
    er()
  File "demo.py", line 3, in er
    print ora
NameError: global name 'ora' is not defined
}}}
Weird, eh?

Changing demorun.py again
{{{
ora = 'cepticool'
def run():
  execfile('demo.py')
run()
}}}
cepticool

I was totally confused when I first encountered this behavior. It was not as clear as in this example. The problem is that you expect function behavior to be *position independent* and with `execfile()` it is not true. It is indirectly explained in [http://docs.python.org/2/library/functions.html#execfile documentation] on its arguments. In addition to `filename`, `execfile()` accepts `globals` and `locals` arguments.  `If both dictionaries are omitted, the expression is executed in the environment where execfile is called.`

There are more confusing references to globals/locals in docs, but the point is that `execfile()` basically inserts Python code in the place where it is called from. Therefore if you execute the `demo.py` inside of the function in demorun.py, it will inherit globals and locals of the function but will lose their own.

Documentation just needs to say that it `execfile` pastes lines of code from file at the place of invocation. If you need to isolate execution, it is done by passing globals and locals arguments. But here is another problem `If two separate objects are passed as globals and locals, the code will be executed as if it were embedded in a class definition`. I don't know what is the effect if embed Python module in a class definition. Anybody? The docs probably say that you need to be smart to use it.

There is another tip that can help with my particular use case. `Remember that at module level, globals and locals are the same dictionary.` I feel like a real Unix hacker now - that probably relates to the fact that executed file is a module and when we execute it, the code inside is executed on a module level. Seems obvious, but didn't work for me. So, the solution to fix execfile() behavior to be position independent is to pass it an empty dictionary.

*recommendation*: simplify `execfile` description.

== Standard library glitches ==

=== os.path.split has platform dependent behavior ===
[http://docs.python.org/2/library/os.path.html#os.path.split os.path.split] non-crossplatform behavior is not documented ([http://bugs.python.org/issue16413 bug #16413]).

`os.path.split('c:foo')` results:
 
 * Windows: `('c:', 'foo')`
 * Linux:   `('', 'c:foo')`

But `os.path.split('foo:bar')` on Windows gives `('', 'foo:bar')`.


Summary: It would be nice to get 'import path' module with predictable cross-platform functions and notes about platform differences.

=== os.path.join counter-intuitive behavior ===
{{{
>>> os.path.join('/static', '/styles/largestyles.css')
'/styles/largestyles.css'
}}}
This is counter-intuitive, because `/static + /static/largestyles.css` does everything right.

Summary: wanted 'import path' module with behavior that is expected from join operation.

=== re.sub discrepancy between matching and substitution groups ===

`\0` doesn't work in Python as a whole matched regexp in substitution string for `re.sub` and friends, but `.group(0)` contains the whole match as expected. http://bugs.python.org/issue17426 This inconsistency is unlikely to be fixed thanks to backward compatibility concerns only and therefore is a wart.

== Standard tools warts ==
=== reStructuredText ===

1. No way to insert empty lines between items in a bullet list
{{{
- item 1

- item 2
}}}
is rendered as
  * item 1
  * item 2
and the following is impossible at all
  * item 1

  * item 2

2. In generated HTML, the structure of parent container depends on its children. For example, load the following into http://rst.ninjs.org to see the extra spacing between list lines:

{{{
first list

- item 1
- item 2
- item 3

second list

- item 1
- item 2::

   example code section
    
- item 3
- item 4
}}}

You can not reliably style HTML produced with reST, and it is considered to be [expected behavior http://sourceforge.net/p/docutils/bugs/178/].

== Links ==

Links to other critique that can be useful for Python refactoring:
 * http://pydanny.blogspot.com/2011/11/redux-python-things-i-dont-like.html
 * http://inventwithpython.com/blog/2012/07/09/16-common-python-runtime-errors/
 * http://packages.python.org/kitchen/unicode-frustrations.html
 * http://zedshaw.com/essays/curing_pythons_neglect.html
 * http://programming.oreilly.com/2013/10/dead-batteries-included.html

 * https://wiki.theory.org/YourLanguageSucks#Python_sucks_because:


Constructive approach to wart invisibility problem from JavaScript guys:
 * http://bonsaiden.github.com/JavaScript-Garden/


Prooflinks:
 1. https://bitbucket.org/techtonik/hexdump/pull-request/1/since-the-input-file-is-a-specific/diff