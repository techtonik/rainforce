#summary Won't fix issues that make Python less pythonic.

Contents:

<wiki:toc />

== Logging hidden magic (2.x tested, 3.x unknown) ==

To make `logging` module more easy to use, e.g.
{{{
import logging

logging.error('SNAFU')
}}}
it makes an automatic configuration when any top level functions like logging.error() are called. More specifically, it implicitly calls `basicConfig()` which is a one-shot function that can be called only once.

As a result, if imported modules are using logging in simplified mode, you have to keep in mind different things about `basicConfig()` that are better to live without.

http://bugs.python.org/issue1164953

This behaviour is confusing for people, its not intuitive. Consider the following two separate Python sessions:
{{{
>>> import logging as l
>>> l.error("x")
ERROR:root:x
>>> l.getLogger('x').error('x')
ERROR:x:x
}}}

{{{
>>> import logging as l
>>> l.getLogger('x').error('x')
No handlers could be found for logger "x"
}}}

http://bugs.python.org/issue1354052

It is also doubtful how to provide default logging configuration for library? For example, when library wants to disable all output by default. If such library is imported after the main logging configuration that enables library output - then such import will break the config.


*recommendation* (ideal case) - Start with study of several use case scenarios:
 # basic 'logging' usage - 'import logging; logging.log()'
 # advanced usage - all imported modules are using 'import logging; logging.log()'
 # more advanced example - mixed usage of named and unnamed loggers in imported modules and root app
 # default behaviour - with two and three level hierarchy of modules


== Logging best practices - specify `__name__` manually ==

Best practices recommend using module `__name__` variable as logger's name. `__name__`  that contains the name under which a module is imported.
{{{
import logging 
logger = logging.getLogger(__name__)
}}}

If the module is executed from command line, `__name__` will equal to `__main__`, if it is imported like `import trac.db.api` then the `__name__` will be equal to `trac.db.api`. Quite convenient.

Now about warts.
 # You need to insert the line `logger = logging.getLogger(__name__)` into every file, even though logging could detect this name automatically and invoke appropriate logger by default using inspect (example code at https://gist.github.com/1291125).
 # [http://docs.python.org/library/logging.html#logrecord-attributes Log record] contains `%(module)s` field that you can use to format message, but this is not the module `__name__` above - it is merely `name portion of %(filename)s`. You need to keep in mind that you need `%(name)s` - name of the logger - here.

*recommendation* - The above can be fixed with Python code, but a lot of logging calls incur performance overhead by logger choosing and filtering. However, if `__name__` convention is adopted by default, the Python internals can be reworked so that filtering is done on a interpreter level even before the code enters log() function.

== Subprocess - implicit argument conversion ==

[http://docs.python.org/library/subprocess.html Subprocess] module did a great job to reduce the number of various ways and pitfalls of executing external programs from Python, but it is not enough.

External programs can be executed directly, or from shell. Why the latter is required is not immediately obvious (IMO it should be explained in Python manual, but I am busy with [http://code.google.com/p/pydotorg/issues/detail?id=6 pydotorg:issue:6] to fix it the old way), but I guess it is to inherit environment variable to find your command is in %PATH%.

The way the program is executed is controlled by `shell` argument to the main subprocess function - `Popen`. However, this changes the meaning of the first argument (defining the command to be executed and its params)  quite significantly. That means it is possible to lose your arguments or pass them to the wrong command or just fail on one platform, but work on the other.

== Subprocess - awkward API ==

If you ever looked at subprocess examples - you may have noticed how lengthy the commands are. Coupled with the above wart, this makes it almost absolutely impossible to use Python as a cross-platform replacement of shell language.

*What can be done?*
Provide helpers with consistent meaning of arguments aimed to solve particular user level tasks:
  # Execute command getting its output for further processing, e.g. `out = callout('svn log %s' % fname)
The argument above can be list only for the sake of quoting it properly (if needed).