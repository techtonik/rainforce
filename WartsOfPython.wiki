#summary Won't fix issues that make Python less pythonic.

Contents:

<wiki:toc />

== stdout buffering ==
Python is a victim of premature optimization.
{{{
import sys
import time

print("get", end="")
time.sleep(3)
print("me")
time.sleep(3)
sys.stdout.write("onscreen")
time.sleep(3)
}}}
In this code phrases "get", and "onscreen" appear only after the sleep operation (Linux, Python 3.2).  To turn this off you need [http://stackoverflow.com/questions/107705/python-output-buffering some monkey-patching hacks].

New Python users are not aware of various buffering, and this issue comes to be very confusing for them. This question that print without newline doesn't work is [http://stackoverflow.com/questions/tagged/python?page=1&sort=votes&pagesize=50 45th from top 100] on StackOverflow.

== Logging ==

Standard Python logging suxx. Prooflinks:
 * [https://github.com/Supervisor/supervisor/blob/master/supervisor/loggers.py Supervisor]
 * [http://twistedmatrix.com/trac/wiki/TwistedLogging Twisted]
 * [http://sayspy.blogspot.com/2009/07/results-of-informal-poll-about-standard.html 3rd place in modules that need redesign]
 * [http://packages.python.org/Logbook/ Logbook - alternative with features that `logging` misses] 

{{{
Q: Why?
A: You will inevitably face with problems below and will have to read a
lengthy doc with proper explanations
Q: Why it can not be fixed?
A: Backwards compatibility
Q: Why not logging2?
A: Some Python developers do not feel that DMMT is sufficient reason
}}}

=== Logging hidden magic (2.x tested, 3.x unknown) ===

To make `logging` module more easy to use, e.g.
{{{
import logging

logging.error('SNAFU')
}}}
it makes an automatic configuration when any top level functions like logging.error() are called. More specifically, it implicitly calls `basicConfig()` which is a one-shot function that can be called only once.

As a result, if imported modules are using logging in simplified mode, you have to keep in mind different things about `basicConfig()` that are better to live without.

http://bugs.python.org/issue1164953

This behaviour is confusing for people, it's not intuitive. Consider the following two separate Python sessions:
{{{
>>> import logging as l
>>> l.error("x")
ERROR:root:x
>>> l.getLogger('x').error('x')
ERROR:x:x
}}}

{{{
>>> import logging as l
>>> l.getLogger('x').error('x')
No handlers could be found for logger "x"
}}}

http://bugs.python.org/issue1354052 <br/>
http://bugs.python.org/issue16539

It is also doubtful how to provide default logging configuration for a library? For example, when library wants to disable all output by default. If such library is imported after the main logging configuration that enables library output - then such import will break the config.


*recommendation* (ideal case) - Start with study of several use case scenarios:
 # basic 'logging' usage - 'import logging; logging.log()'
 # advanced usage - all imported modules are using 'import logging; logging.log()'
 # more advanced example - mixed usage of named and unnamed loggers in imported modules and root app
 # default behaviour - with two and three level hierarchy of modules


=== Logging best practices - specify `__name__` manually ===

Best practices recommend using module `__name__` variable as logger's name. `__name__`  that contains the name under which a module is imported.
{{{
import logging 
logger = logging.getLogger(__name__)
}}}

If the module is executed from command line, `__name__` will equal to `__main__`, if it is imported like `import trac.db.api` then the `__name__` will be equal to `trac.db.api`. Quite convenient.

Now about warts.
 # The first time you call warning(), error() or critical() you'll get 'No handlers could be found for logger "__main__" (Python 2.x, http://bugs.python.org/issue16539)

*recommendation* - For Python 2.x [http://hg.python.org/cpython/file/771f28686022/Lib/logging/__init__.py#l1669 copy NullHandler] from Python 2.7 to your library and add it as:
{{{
logger.addHandler(NullHandler())
}}}

Warts continued.
 # You need to insert the line `logger = logging.getLogger(__name__)` into every file, even though logging could detect this name automatically and invoke appropriate logger by default using inspect (example code at https://gist.github.com/1291125).
 # [http://docs.python.org/library/logging.html#logrecord-attributes Log record] contains `%(module)s` field that you can use to format message, but this is not the module `__name__` above - it is merely `name portion of %(filename)s`. You need to keep in mind that you need `%(name)s` - name of the logger - here.

*recommendation* - The above can be fixed with Python code, but a lot of logging calls incur performance overhead by logger choosing and filtering. However, if `__name__` convention is adopted by default, the Python internals can be reworked so that filtering is done on a interpreter level even before the code enters log() function.

== Subprocess ==

=== Subprocess - implicit argument conversion ===

[http://docs.python.org/library/subprocess.html Subprocess] module did a great job to reduce the number of various ways and pitfalls of executing external programs from Python, but it is not enough.

External programs can be executed directly, or from shell. Why the latter is required is not immediately obvious (IMO it should be explained in Python manual, but I am busy with [http://code.google.com/p/pydotorg/issues/detail?id=6 pydotorg:issue:6] to fix it the old way), but I guess it is to inherit environment variable to find your command is in %PATH%.

The way the program is executed is controlled by `shell` argument to the main subprocess function - `Popen`. However, this changes the meaning of the first argument (defining the command to be executed and its params)  quite significantly. That means it is possible to lose your arguments or pass them to the wrong command or just fail on one platform, but work on the other.

=== Subprocess - awkward API ===

If you ever looked at subprocess examples - you may have noticed how lengthy the commands are. Coupled with the above wart, this makes it almost absolutely impossible to use Python as a cross-platform replacement of shell language.

*What can be done?*
Provide helpers with consistent meaning of arguments aimed to solve particular user level tasks:
  # Execute command getting its output for further processing, e.g. `out = callout('svn log %s' % fname)
The argument above can be list only for the sake of quoting it properly (if needed).

== Measuring run time ==

_There should be one-- and preferably only one --obvious way to do it._
{{{
>>> from datetime import datetime
>>> s = datetime.now()
>>> str(datetime.now() - s)
'0:00:11.475000'
}}}

{{{
>>> from time import time
>>> s = time()
>>> str(time() - s)
'11.8889999389'
}}}

*What can be done?*
{{{
>>> import timer
>>> timer.get(precision=2)
'0:00:11.47'
>>> timer.start('newtimername')
>>> timer.get('newtimername')
'0:00:11.475000'
}}}

== Standard library glitches ==

=== os.path.split has platform dependent behavior ===
[http://docs.python.org/2/library/os.path.html#os.path.split os.path.split] non-crossplatform behavior is not documented ([http://bugs.python.org/issue16413 bug #16413]).

`os.path.split('c:foo')` results:
 
 * Windows: `('c:', 'foo')`
 * Linux:   `('', 'c:foo')`

But `os.path.split('foo:bar')` on Windows gives `('', 'foo:bar')`.


Summary: It would be nice to get 'import path' module with predictable cross-platform functions and notes about platform differences.

== Links ==

Links to other critique that can be useful for Python refactoring:
 # http://pydanny.blogspot.com/2011/11/redux-python-things-i-dont-like.html
 # http://inventwithpython.com/blog/2012/07/09/16-common-python-runtime-errors/
 # http://packages.python.org/kitchen/unicode-frustrations.html